/**
 * DO NOT EDIT THIS FILE DIRECTLY.
 * This file is generated following the conversion of
 *
 * @see [./src/http/fetch.node.js]{@link ./src/http/fetch.node.js}
 *
 **/
// @ts-ignore
import { Request, Response, Headers } from '../fetch.js'
import { Readable } from 'node:stream'
// @ts-ignore
/**
 * @typedef {import('stream').Readable} NodeReadableStream
 *
 * @typedef {import('../types').FetchOptions} FetchOptions
 * @typedef {import('../types').ProgressFn} ProgressFn
 */

/**
 * @param {string|Request} url
 * @param {FetchOptions} [options]
 * @returns {Promise<Response>}
 */
const fetch = (url, options = {}) =>
  globalThis.fetch(url, withUploadProgress(options))

/**
 * Takes fetch options and wraps request body to track upload progress if
 * `onUploadProgress` is supplied. Otherwise returns options as is.
 *
 * @param {FetchOptions} options
 * @returns {FetchOptions}
 */
const withUploadProgress = (options) => {
  const { onUploadProgress, body } = options
  if (onUploadProgress && body) {
    // This works around the fact that electron-fetch serializes `Uint8Array`s
  // and `ArrayBuffer`s to strings.
    const content = normalizeBody(body)

    const rsp = new Response(content)
    const source = iterateBodyWithProgress(rsp.body, onUploadProgress)
    const stream = Readable.from(source)
    return {
      ...options,
      body: Readable.toWeb(stream)
    }
  } else {
    return options
  }
}

/**
 * @param {BodyInit} input
 * @returns {BodyInit}
 */
const normalizeBody = (input) => {
  if (input instanceof ArrayBuffer) {
    return input
  } else if (ArrayBuffer.isView(input)) {
    const arrayBuffer = new ArrayBuffer(input.byteLength);
    new Uint8Array(arrayBuffer).set(new Uint8Array(input.buffer, input.byteOffset, input.byteLength));
    return arrayBuffer;
  }
  else return input
}

/**
 * Takes body from native-fetch response as body and `onUploadProgress` handler
 * and returns async iterable that emits body chunks and emits
 * `onUploadProgress`.
 *
 * @param {ReadableStream | ArrayBuffer | ArrayBufferView | null} body
 * @param {ProgressFn} onUploadProgress
 * @returns {AsyncIterable<Uint8Array>}
 */
const iterateBodyWithProgress = async function* (body, onUploadProgress) {
  if (body == null) {
      onUploadProgress({ total: 0, loaded: 0, lengthComputable: true });
  } else if (ArrayBuffer.isView(body)) {
      const total = body.byteLength;
      const lengthComputable = true;
      yield new Uint8Array(body.buffer, body.byteOffset, body.byteLength);
      onUploadProgress({ total, loaded: total, lengthComputable });
  } else if ('getReader' in body) {
      const reader = body.getReader();
      const total = 0; // If the total size is unknown
      const lengthComputable = false;
      let loaded = 0;

      try {
          while (true) {
              const { done, value } = await reader.read();
              if (done) break;

              loaded += value.byteLength;
              yield value; // Yield the chunk
              onUploadProgress({ total, loaded, lengthComputable });
          }
      } finally {
          reader.releaseLock(); // Ensure the reader lock is released
      }
  }
};

export default {
  fetch,
  Request,
  Headers
}
